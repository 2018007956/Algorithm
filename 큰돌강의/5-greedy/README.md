# Greedy
"~상태에서는 ~가 최선이다"라는 명제 생각해내기  
옳은 명제를 찾아서 구현하는게 그리디

## 그리디의 조건
그리디 알고리즘을 실행하려면 다음과 같은 조건이 충족되어야 한다.  
1. 최적부분구조 (Optimal Substructure)  
   문제를 작은 부분 문제로 나눌 수 있으며, 그 부분 문제들의 최적해가 모여서 전체 문제의 최적해를 이룰 수 있는 구조
2. 탐욕 선택속성  
   각 단계에서의 최적 선택이 전체 문제에 대해서도 최적의 해를 보장한다는 것을 의미  
   즉, 그 숭간 가장 최적인 선택을 하는 것이 전체 문제를 푸는 데 있어서도 최적의 결과를 낳는다는 것

## 현실적인 풀이법
원래 그리디 알고리즘을 정석적으로 하기에는 "~~를 위해서 탐욕적으로 ~~를 해야한다."라는 명제를 증명하고,  
해당 명제가 맞는 것임을 확인한 후 그 명제로 문제를 풀어야 한다.  
하지만 이러한 것을 코딩테스트에서 하기에는 불가능하다.  
**어떤 명제를 생각한다음 -> 어떠한 상태값(idx, here 등..)에서 가장 최적의 로직은 무엇일까 생각하고  
-> 코드로 구현 -> 해당 명제가 틀렸다면 -> 빠르게 변경해서 다시 푼다**

- 명제가 틀릴 가능성이 높기 때문에 그리디는 최종병기 방법
- Bruth Force -> DP -> Greedy 순으로 고민
  - 그리디로 풀 수 있는 문제는 DP로도 풀 수 있는 경우가 많음
  - 그리디로 되는데 DP로 안되는 경우는 저장해야하는 정점이 많은 경우

보통 그리디 알고리즘은 **정렬이나 우선순위큐(PQ) 또는 둘 다** 쓰면 풀리는 경우가 대다수다


# Line Sweeping
교차점, 점과 점의 집합 찾기 등 기하문제를 풀 때 사용되는데,  
코딩테스트에는 그정도 기하수준은 나오지 않기 때문에 이 부분은 신경 쓸 필요가 없으며  
그저 구간과 관련된 문제에서 **최대의 구간, 횟수** 등을 찾는데 많이 쓰이는 알고리즘이다.  


# Two Pointers
배열이나 리스트와 같은 선형 자료구조에서 두 개의 포인터를 사용하여 정렬된 배열에서  
특정 조건을 만족하는 부분 배열 또는 원하는 값을 찾는 등의 문제를 풀 때 주로 사용하는 알고리즘이다.  
보통 **정렬된 배열에서 두 수의 합 찾기, 연속된 부분배열의 합 찾기**에 사용된다.