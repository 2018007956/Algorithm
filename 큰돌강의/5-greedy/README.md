# Greedy
"~상태에서는 ~가 최선이다"라는 명제 생각해내기  
옳은 명제를 찾아서 구현하는게 그리디

## 그리디의 조건
그리디 알고리즘을 실행하려면 다음과 같은 조건이 충족되어야 한다.  
1. 최적부분구조 (Optimal Substructure)  
   문제를 작은 부분 문제로 나눌 수 있으며, 그 부분 문제들의 최적해가 모여서 전체 문제의 최적해를 이룰 수 있는 구조
2. 탐욕 선택속성  
   각 단계에서의 최적 선택이 전체 문제에 대해서도 최적의 해를 보장한다는 것을 의미  
   즉, 그 숭간 가장 최적인 선택을 하는 것이 전체 문제를 푸는 데 있어서도 최적의 결과를 낳는다는 것

## 현실적인 풀이법
원래 그리디 알고리즘을 정석적으로 하기에는 "~~를 위해서 탐욕적으로 ~~를 해야한다."라는 명제를 증명하고,  
해당 명제가 맞는 것임을 확인한 후 그 명제로 문제를 풀어야 한다.  
하지만 이러한 것을 코딩테스트에서 하기에는 불가능하다.  
**어떤 명제를 생각한다음 -> 어떠한 상태값(idx, here 등..)에서 가장 최적의 로직은 무엇일까 생각하고  
-> 코드로 구현 -> 해당 명제가 틀렸다면 -> 빠르게 변경해서 다시 푼다**

- 명제가 틀릴 가능성이 높기 때문에 그리디는 최종병기 방법
- Bruth Force -> DP -> Greedy 순으로 고민

보통 그리디 알고리즘은 **정렬이나 우선순위큐(PQ) 또는 둘 다** 쓰면 풀리는 경우가 대다수다