-- 진료과별 총 예약 횟수 출력하기
SELECT MCDP_CD AS '진료과코드', COUNT(MCDP_CD) AS '5월예약건수'
    FROM APPOINTMENT
    WHERE APNT_YMD LIKE '2022-05%'
    GROUP BY MCDP_CD
    ORDER BY 2, MCDP_CD;

-- 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기
SELECT CAR_TYPE, COUNT(CAR_TYPE) AS CARS
    FROM CAR_RENTAL_COMPANY_CAR
    WHERE OPTIONS REGEXP '통풍시트|열선시트|가죽시트'
    GROUP BY CAR_TYPE
    ORDER BY CAR_TYPE;

-- 동명 동물 수 찾기
SELECT NAME, COUNT(*)
    FROM ANIMAL_INS
    GROUP BY NAME
    HAVING COUNT(NAME)>=2 
    ORDER BY NAME
/* COUNT(*)>=2 로 하면 틀림
-> COUNT(*)는 NULL인 행도 포함해서 모든 행 수를 셈
-> COUNT(NAME)는 NAME이 NULL이 아닌 값만 셈 */

-- 가격대 별 상품 개수 구하기
SELECT (PRICE DIV 10000) * 10000, COUNT(*) AS PRODUCTS
    FROM PRODUCT
    GROUP BY 1
    ORDER BY 1

SELECT FLOOR(PRICE / 10000) * 10000, COUNT(*) AS PRODUCTS
    FROM PRODUCT
    GROUP BY 1
    ORDER BY 1

-- 노선별 평균 역 사이 거리 조회하기
SELECT ROUTE, CONCAT(ROUND(SUM(D_BETWEEN_DIST), 1), 'km') AS TOTAL_DISTANCE, CONCAT(ROUND(AVG(D_BETWEEN_DIST), 2), 'km') AS AVERAGE_DISTANCE
    FROM SUBWAY_DISTANCE
    GROUP BY ROUTE
    ORDER BY ROUND(SUM(D_BETWEEN_DIST), 1) DESC
/* ORDER BY 2 DESC 로 하면 틀림
-> 문자열 정렬이 돼버려서 문자 단위로 왼쪽부터 아스키값 기준으로 비교하기 때문 */

-- 물고기 종류 별 잡은 수 구하기
SELECT COUNT(*) AS FISH_COUNT, N.FISH_NAME
    FROM FISH_INFO I
    JOIN FISH_NAME_INFO N
    ON N.FISH_TYPE=I.FISH_TYPE
    GROUP BY N.FISH_NAME
    ORDER BY 1 DESC
/* 물고기의 종류 별로 출력하라해서 GROUP BY I.FISH_TYPE 이라고 했는데 틀림
-> FISH_TYPE과 FISH_NAME은 1:N 관계일 수 있음 
-> FISH_TYPE으로 그루핑하면 FISH_NAME이 여러 개 있을 수 있어서 어떤 걸 보여줘야 할지 모호함
-> 지금 SQL 설정이 ONLY_FULL_GROUP_BY 모드와 호환되지 않는다는 에러 발생 */

-- 월별 잡은 물고기 수 구하기
SELECT COUNT(*) AS FISH_COUNT, MONTH(TIME) AS MONTH
    FROM FISH_INFO
    GROUP BY 2
    ORDER BY 2

SELECT COUNT(*) AS FISH_COUNT, SUBSTR(TIME, 6, 2) + 0 AS MONTH
    FROM FISH_INFO
    GROUP BY 2
    ORDER BY 2

SELECT COUNT(*) AS FISH_COUNT, CAST(SUBSTR(TIME, 6, 2) AS UNSIGNED) AS MONTH
    FROM FISH_INFO
    GROUP BY 2
    ORDER BY 2
/* SIGNED : 부호 있는 숫자 (INT = SIGNED INT)
   UNSIGNED : 부호 없는 숫자 */

-- 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기
SELECT MONTH(START_DATE) AS MONTH, CAR_ID, COUNT(*) AS RECORDS
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) BETWEEN 8 AND 10
        AND CAR_ID IN (
            SELECT CAR_ID
            FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
            WHERE MONTH(START_DATE) BETWEEN 8 AND 10 
            GROUP BY CAR_ID
            HAVING COUNT(CAR_ID) >= 5
        )
    GROUP BY 1, 2
    ORDER BY 1, 2 DESC

-- 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기
SELECT CAR_ID, 
        MAX(CASE WHEN '2022-10-16' BETWEEN START_DATE AND END_DATE THEN '대여중'
             ELSE '대여 가능'
        END) AS AVAILABILITY
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    GROUP BY 1
    ORDER BY 1 DESC
/* 한 CAR_ID에 대해 어떤 날짜가 '대여중'인 기록이 1개라도 있다면,
'대여중'이 사전순으로 더 크므로 MAX 결과는 '대여중'이 됨 */

SELECT CAR_ID,
    CASE
        WHEN CAR_ID IN (
            SELECT CAR_ID
            FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
            WHERE '2022-10-16' BETWEEN START_DATE AND END_DATE) THEN '대여중'
        ELSE '대여 가능'
    END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC

-- 즐겨찾기가 가장 많은 식당 정보 출력하기
SELECT FOOD_TYPE, REST_ID, REST_NAME, FAVORITES
    FROM REST_INFO A
    WHERE FAVORITES = (
        SELECT MAX(FAVORITES)
        FROM REST_INFO
        WHERE FOOD_TYPE = A.FOOD_TYPE
    )
    ORDER BY 1 DESC

-- 조건에 맞는 사용자의 총 거래금액 조회하기
SELECT U.USER_ID, U.NICKNAME, SUM(B.PRICE) AS TOTAL_SALES
    FROM USED_GOODS_BOARD B
    JOIN USED_GOODS_USER U ON B.WRITER_ID=U.USER_ID
    WHERE B.STATUS='DONE'
    GROUP BY B.WRITER_ID
    HAVING TOTAL_SALES >= 700000
    ORDER BY 3
/* B.STATUS='DONE'를 HAVING 절에 정의하면 안됨
-> HAVING절은 GROUP BY로 집계한 컬럼 또는 SELECT에서 정의된 집계 관련 별칭만 사용할 수 있다 */

-- 저자 별 카테고리 별 매출액 집계하기
SELECT A.AUTHOR_ID, AUTHOR_NAME, CATEGORY, SUM((
        SELECT SUM(SALES)
        FROM BOOK_SALES
        WHERE SUBSTR(SALES_DATE, 1, 7) = '2022-01' AND B.BOOK_ID=BOOK_ID
        GROUP BY BOOK_ID
    ) * PRICE) AS TOTAL_SALES
    FROM AUTHOR A
    JOIN BOOK B ON A.AUTHOR_ID=B.AUTHOR_ID
    GROUP BY 1, 3
    ORDER BY 1, 3 DESC

SELECT A.AUTHOR_ID, AUTHOR_NAME, CATEGORY, SUM(SALES * PRICE) AS TOTAL_SALES
FROM BOOK_SALES S
JOIN BOOK B ON S.BOOK_ID = B.BOOK_ID
JOIN AUTHOR A ON B.AUTHOR_ID = A.AUTHOR_ID
WHERE SUBSTR(S.SALES_DATE, 1, 7) = '2022-01'
GROUP BY 1, 3
ORDER BY 1, 3 DESC

-- 식품분류별 가장 비싼 식품의 정보 조회하기
SELECT CATEGORY, PRICE AS MAX_PRICE, PRODUCT_NAME
    FROM FOOD_PRODUCT A
    WHERE PRICE = (
        SELECT MAX(PRICE) 
        FROM FOOD_PRODUCT
        WHERE CATEGORY = A.CATEGORY
        GROUP BY CATEGORY
    ) AND CATEGORY IN ('과자', '국', '김치', '식용유')
    ORDER BY 2 DESC

-- 년, 월, 성별 별 상품 구매 회원 수 구하기
SELECT YEAR(SALES_DATE) AS YEAR, MONTH(SALES_DATE) AS MONTH, GENDER, COUNT(DISTINCT O.USER_ID) AS USERS
    FROM ONLINE_SALE O
    JOIN USER_INFO U ON O.USER_ID=U.USER_ID
    WHERE GENDER IS NOT NULL
    GROUP BY 1, 2, 3
    ORDER BY 1, 2, 3
/* GROUP BY로 묶인 각 그룹에 대해 HAVING으로 조건 검사 후 SELECT (최종 컬럼 연산) 수행
-> WHERE GENDER IS NOT NULL 대신 GROUP BY 뒤에 HAVING GENDER IS NOT NULL 넣어도 정답 */

-- 입양 시각 구하기 2
SET @hour := -1;
SELECT (@hour := @hour + 1) AS HOUR,
    (
        SELECT COUNT(*)
        FROM ANIMAL_OUTS
        WHERE HOUR(DATETIME) = @hour
    ) AS COUNT
FROM ANIMAL_OUTS
WHERE @hour < 23;
/* @가 붙은 변수는 프로시저가 종료되어도 유지된다
SQL 문법에서 :=은 비교 연산자 =과 혼동을 피하기 위한 대입 연산 */

-- 언어별 개발자 분류하기
WITH FE AS (
    SELECT SUM(CODE)
    FROM SKILLCODES
    WHERE CATEGORY='Front End'
)

SELECT
    CASE
        WHEN SKILL_CODE & (SELECT * FROM FE)
            AND SKILL_CODE & (SELECT CODE FROM SKILLCODES WHERE NAME = 'Python') THEN 'A'
        WHEN SKILL_CODE & (SELECT CODE FROM SKILLCODES WHERE NAME = 'C#') THEN 'B'
        WHEN SKILL_CODE & (SELECT * FROM FE) THEN 'C'
        ELSE NULL
    END AS GRADE
    , ID
    , EMAIL
FROM DEVELOPERS
HAVING GRADE IS NOT NULL
ORDER BY 1, 2
/* WHERE이 아니라 HAVING이어야 하는 이유?
-> GRADE는 SELECT절에서 정의된 별칭(alias)이고, MYSQL에서는 HAVING절로 필터링 가능
쿼리문 실행 순서는 (FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY > LIMIT)이긴 함 */

SELECT *
FROM (
    SELECT
        CASE
            WHEN SKILL_CODE & (SELECT SUM(CODE) FROM SKILLCODES WHERE CATEGORY='Front End')
                AND SKILL_CODE & (SELECT CODE FROM SKILLCODES WHERE NAME = 'Python') THEN 'A'
            WHEN SKILL_CODE & (SELECT CODE FROM SKILLCODES WHERE NAME = 'C#') THEN 'B'
            WHEN SKILL_CODE & (SELECT SUM(CODE) FROM SKILLCODES WHERE CATEGORY='Front End') THEN 'C'
            ELSE NULL
        END AS GRADE,
        ID,
        EMAIL
    FROM DEVELOPERS
) T
WHERE GRADE IS NOT NULL
ORDER BY 1, 2;
/* WHERE로 필터링 하고자 하면, 위와 같이 GRADE 로직을 서브쿼리로 감싸야 됨 */